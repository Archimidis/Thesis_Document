\chapter{Πρωτόκολλα Αρχιτεκτονικής}
\label{chap:Protocols}

\section{Εισαγωγή}

Στο παρόν κεφάλαιο περιγράφονται τα πρωτόκολλα του συστήματος. Η βιβλιοθήκη 
έχει βασιστεί στο P-Grid και επομένως υλοποιείται ο αλγόριθμος exchange 
όπως έχει οριστεί στο \citep{Abererb}. Θα γίνει μια μικρή περιγραφή του. 
Στη συνέχεια αναλύεται διεξοδικά το πρωτόκολλο ανοχής λαθών που η ανάπτυξή 
του είναι και ένας από τους στόχους της διπλωματικής εργασίας.

\section{Πρωτόκολλο Exchange}

To P-Grid δίκτυο κατασκευάζεται μέσω των αλληλεπιδράσεων μεταξύ των peer. 
Ο τρόπος με τον οποίο ένα P-Grid δίκτυο κατασκευάζεται είναι μέσω του 
αλγορίθμου exchange. Στα σχήματα \ref{algo:ExchangePart1} και 
\ref{algo:ExchangePart2} παρουσιάζεται ο αλγόριθμος και ακολουθεί η 
ανάλυση του.

Αρχικά, κατά τα πρώτα στάδια εκκίνησης του δικτύου, οι peer είναι υπεύθυνοι 
για όλο τον χώρο κλειδιών. Δεν υπάρχουν κατατμήσεις και όλοι οι peer 
αντιστοιχούν στο ριζικό μονοπάτι του δέντρου. Ο αλγόριθμος exchange 
καθορίζει τον τρόπο με τον οποίο ο χώρος κλειδιών θα διασπαστεί σε 
περισσότερες εξειδικεύσεις. Κάθε μια από αυτές τίθεται υπό την ευθύνη 
ενός peer. Ο αλγόριθμος εκτελείται με την πρώτη ευκαιρία που δύο peer 
θα συναντηθούν.

Οι peer ελέγχονται πάνω στο μονοπάτι για το οποίο είναι υπεύθυνοι. 
Σε κάθε εκτέλεση του αλγορίθμου, οι δυο peer ανανεώνουν τους πίνακες 
δρομολόγησης τους. Αρχικά, ανταλλάσσουν τυχαία αναφορές προς peer για όλα 
τα επίπεδα του κοινού προθέματος.

\paragraph{Περίπτωση 1.} Η πρώτη περίπτωση του αλγορίθμου προκύπτει όταν 
αυτοί αντιστοιχούν στο ίδιο μονοπάτι, έστω $x$. Τότε και οι δύο peer 
εξειδικεύονται περαιτέρω προς αντίθετες κατευθύνσεις. Ο ένας θα αναλάβει 
το μονοπάτι $χ0$ και ο άλλος το συζυγές $χ1$. Κάθε peer προσθέτει τον άλλον 
στον πίνακα δρομολόγησης ως υπεύθυνο για το νέο επίπεδο που δημιουργήθηκε 
στο μονοπάτι.

\paragraph{Περιπτώσεις 2 και 3.}Η δεύτερη και η τρίτη περίπτωση είναι 
παρόμοιες. Το μονοπάτι του ενός peer είναι μικρότερο από αυτό του άλλου 
και μάλιστα είναι και πρόθεμα του. Στην περίπτωση αυτή, ο λιγότερο 
εξειδικευμένος peer προχωρά προς την αντίθετη κατεύθυνση. Αν παράδειγμα 
αυτός είχε το μονοπάτι $x$ και ο άλλος peer το $x1$, τότε ο πρώτος 
εξειδικεύεται προς το $x0$. Επίσης, ανανεώνονται και οι αναφορές στους 
πίνακες δρομολόγησης. Παρατηρούμε, πως αν ο peer $a1$ αντιστοιχεί το 
μικρότερο μονοπάτι, τότε κατά την εκτέλεση του αλγορίθμου αυτός θα είναι 
στην δεύτερη περίπτωση ενώ ο $a2$ στην τρίτη.

\paragraph{Περίπτωση 4.} Τέλος, έχουμε την περίπτωση όπου οι δυο peer 
μοιράζονται ένα κοινό πρόθεμα αλλά από εκεί και μετά έχουν ακολουθήσει 
διαφορετικού δρόμους στο δέντρο. Εδώ ο αλγόριθμος εκτελείται αναδρομικά. 
Οι peer $a1$ και $a2$ προωθούν αιτήσεις για εκτέλεση του αλγορίθμου στους 
peer που έχουν αποθηκευμένους στους πίνακες δρομολόγησης. Όταν 
το δίκτυο φτάσει στην τελική του μορφή, ο χώρος κλειδιών θα έχει διασπαστεί 
σε τόσα κομμάτια όσος και ο αριθμός των peer. Τότε θα προκύπτει συνεχώς η 
τέταρτη περίπτωση κατά την εκτέλεση του αλγορίθμου. Η σταθερά $recmax$ 
θέτει ένα άνω όριο στον αριθμό των αναδρομών που θα εκτελεστούν και είναι 
μια συνθήκη τερματισμού.

%Στην αρχική μορφή του αλγορίθμου που περιγράφεται στη δημοσίευση 
%\citep{Abererb}, τίθεται ένα όριο μέχρι το οποίο μπορεί να εξειδικευτούν 
%οι peer. Ο λόγος ήταν η ομοιόμορφη κατανομή των μονοπατιών θεωρώντας πως 
%επηρεάζει


\begin{algorithm}
\caption{Αλγόριθμος exchange, μέρος 1ο}
\label{algo:ExchangePart1}
\begin{algorithmic}[1]
    \Procedure{exchange}{a1, a2, r} 
        \State commonpath = common\_prefix\_of(path(a1), path(a2));
        \State lc = length(commonpath);
        \If{(lc > 0)}
        \Comment{exchange references at the level where the paths agree}
            \State commonrefs = union(refs(lc, a1), refs(lc, a2));
            \State refs(lc, a1) = random\_select(refmax, commonrefs);
            \State refs(lc, a2) = random\_select(refmax, commonrefs);
            \State l1 = length(sub\_path(path(a1), lc + 1, length(path(a1))));
            \State l2 = length(sub\_path(path(a2), lc + 1, length(path(a2))));            
\newline \Comment{Case 1: if both remaining paths are empty introduce a new level}
            \If{(l1 = 0 $\And$ l2 = 0)}            
                \State path(a1) = append(path(a1), 0);
                \State path(a2) = append(path(a2), 1);
                \State refs(lc + 1, a1) = {a2};
                \State refs(lc + 1, a2) = {a1};
            \EndIf
\newline \Comment{Case 2: if one remaining path is empty split the shorter path}
            \If{(l1 = 0 $\And$ l2 > 0)}
                \State path(a1) = append(path(a1), $\neg$value(lc + 1, path(a2)));
                \State refs(lc + 1, a1) = {a2};
                \State refs(lc + 1, a2) = random\_select(refmax, union({a1}, refs(lc + 1, a2)));
            \EndIf
\algstore{ExchangeBreak}
\end{algorithmic}
\end{algorithm}

\begin{algorithm}[h]
\caption{Αλγόριθμος exchange, μέρος 2ο}
\label{algo:ExchangePart2}
\begin{algorithmic}[1]
\algrestore{ExchangeBreak}
\item[] \Comment{Case 3: like case 2}
            \If{(l1 > 0 $\And$ l2 = 0)}
                \State path(a2) = append(path(a2), $\neg$value(lc + 1, path(a1)));
                \State refs(lc + 1, a2) = {a1};
                \State refs(lc + 1, a1) = random\_select(refmax, union({a2}, refs(lc + 1, a1)));
            \EndIf
\newline \Comment{Case 4: recursively perform exchange with referenced peers}
            \If{(l1 > 0 $\And$ l2 > 0 $\And$ r < recmax)}
                \State refs1 = refs(lc + 1, a1) $\setminus$ {a2};
                \State refs2 = refs(lc + 1, a2) $\setminus$ {a1};
                \For{r1 $\in$ refs1}
                    \If{online(peer(r1))}
                        \State exchange(a2, peer(r1), r + 1)
                    \EndIf
                \EndFor
                \For{r2 $\in$ refs2}
                    \If{online(peer(r2))}
                        \State exchange(a1, peer(r2), r + 1)
                    \EndIf
                \EndFor
            \EndIf
        \EndIf
  \EndProcedure
\end{algorithmic}
\end{algorithm}


\section{Πρωτόκολλο Ανοχής Λαθών (Fault-Tolerance)}

\ \ \ \ TODO
