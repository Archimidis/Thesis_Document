\chapter{Πρωτόκολλα Αρχιτεκτονικής}
\label{chap:Protocols}

\section{Εισαγωγή}

Στο παρόν κεφάλαιο περιγράφονται τα πρωτόκολλα του συστήματος. Η βιβλιοθήκη 
έχει βασιστεί στο P-Grid και επομένως υλοποιείται ο αλγόριθμος exchange 
όπως έχει οριστεί στο \citep{Abererb}. Θα γίνει μια μικρή περιγραφή του. 
Στη συνέχεια αναλύεται διεξοδικά το πρωτόκολλο ανοχής λαθών που η ανάπτυξή 
του είναι και ένας από τους στόχους της διπλωματικής εργασίας.

\section{Πρωτόκολλο Exchange}

To P-Grid δίκτυο κατασκευάζεται μέσω των αλληλεπιδράσεων μεταξύ των peer. 
Ο τρόπος με τον οποίο ένα P-Grid δίκτυο κατασκευάζεται είναι μέσω του 
αλγορίθμου exchange. Στα σχήματα \ref{algo:ExchangePart1} και 
\ref{algo:ExchangePart2} παρουσιάζεται ο αλγόριθμος και ακολουθεί η 
ανάλυση του.

Αρχικά, κατά τα πρώτα στάδια εκκίνησης του δικτύου, οι peer είναι υπεύθυνοι 
για όλο τον χώρο κλειδιών. Δεν υπάρχουν κατατμήσεις και όλοι οι peer 
αντιστοιχούν στο ριζικό μονοπάτι του δέντρου. Ο αλγόριθμος exchange 
καθορίζει τον τρόπο με τον οποίο ο χώρος κλειδιών θα διασπαστεί σε 
περισσότερες εξειδικεύσεις. Κάθε μια από αυτές τίθεται υπό την ευθύνη 
ενός peer. Ο αλγόριθμος εκτελείται με την πρώτη ευκαιρία που δύο peer 
θα συναντηθούν.

Οι peer ελέγχονται πάνω στο μονοπάτι για το οποίο είναι υπεύθυνοι. 
Σε κάθε εκτέλεση του αλγορίθμου, οι δυο peer ανανεώνουν τους πίνακες 
δρομολόγησης τους. Αρχικά, ανταλλάσσουν τυχαία αναφορές προς peer για όλα 
τα επίπεδα του κοινού προθέματος.

\paragraph{Περίπτωση 1.} Η πρώτη περίπτωση του αλγορίθμου προκύπτει όταν 
αυτοί αντιστοιχούν στο ίδιο μονοπάτι, έστω $x$. Τότε και οι δύο peer 
εξειδικεύονται περαιτέρω προς αντίθετες κατευθύνσεις. Ο ένας θα αναλάβει 
το μονοπάτι $χ0$ και ο άλλος το συζυγές $χ1$. Κάθε peer προσθέτει τον άλλον 
στον πίνακα δρομολόγησης ως υπεύθυνο για το νέο επίπεδο που δημιουργήθηκε 
στο μονοπάτι.

\paragraph{Περιπτώσεις 2 και 3.}Η δεύτερη και η τρίτη περίπτωση είναι 
παρόμοιες. Το μονοπάτι του ενός peer είναι μικρότερο από αυτό του άλλου 
και μάλιστα είναι και πρόθεμα του. Στην περίπτωση αυτή, ο λιγότερο 
εξειδικευμένος peer προχωρά προς την αντίθετη κατεύθυνση. Αν παράδειγμα 
αυτός είχε το μονοπάτι $x$ και ο άλλος peer το $x1$, τότε ο πρώτος 
εξειδικεύεται προς το $x0$. Επίσης, ανανεώνονται και οι αναφορές στους 
πίνακες δρομολόγησης. Παρατηρούμε, πως αν ο peer $a1$ αντιστοιχεί το 
μικρότερο μονοπάτι, τότε κατά την εκτέλεση του αλγορίθμου αυτός θα είναι 
στην δεύτερη περίπτωση ενώ ο $a2$ στην τρίτη.

\paragraph{Περίπτωση 4.} Τέλος, έχουμε την περίπτωση όπου οι δυο peer 
μοιράζονται ένα κοινό πρόθεμα αλλά από εκεί και μετά έχουν ακολουθήσει 
διαφορετικού δρόμους στο δέντρο. Εδώ ο αλγόριθμος εκτελείται αναδρομικά. 
Οι peer $a1$ και $a2$ προωθούν αιτήσεις για εκτέλεση του αλγορίθμου στους 
peer που έχουν αποθηκευμένους στους πίνακες δρομολόγησης. Όταν 
το δίκτυο φτάσει στην τελική του μορφή, ο χώρος κλειδιών θα έχει διασπαστεί 
σε τόσα κομμάτια όσος και ο αριθμός των peer. Τότε θα προκύπτει συνεχώς η 
τέταρτη περίπτωση κατά την εκτέλεση του αλγορίθμου. Η σταθερά $recmax$ 
θέτει ένα άνω όριο στον αριθμό των αναδρομών που θα εκτελεστούν και είναι 
μια συνθήκη τερματισμού.

%Στην αρχική μορφή του αλγορίθμου που περιγράφεται στη δημοσίευση 
%\citep{Abererb}, τίθεται ένα όριο μέχρι το οποίο μπορεί να εξειδικευτούν 
%οι peer. Ο λόγος ήταν η ομοιόμορφη κατανομή των μονοπατιών θεωρώντας πως 
%επηρεάζει


\begin{algorithm}
\caption{Αλγόριθμος Exchange, μέρος 1ο}
\label{algo:ExchangePart1}
\begin{algorithmic}[1]
    \Procedure{Exchange}{a1, a2, r} 
        \State commonpath = common\_prefix\_of(path(a1), path(a2));
        \State lc = length(commonpath);
        \If{(lc > 0)}
        \Comment{exchange references at the level where the paths agree}
            \State commonrefs = union(refs(lc, a1), refs(lc, a2));
            \State refs(lc, a1) = random\_select(refmax, commonrefs);
            \State refs(lc, a2) = random\_select(refmax, commonrefs);
            \State l1 = length(sub\_path(path(a1), lc + 1, length(path(a1))));
            \State l2 = length(sub\_path(path(a2), lc + 1, length(path(a2))));            
\newline \Comment{Case 1: if both remaining paths are empty introduce a new level}
            \If{(l1 = 0 $\And$ l2 = 0)}            
                \State path(a1) = append(path(a1), 0);
                \State path(a2) = append(path(a2), 1);
                \State refs(lc + 1, a1) = {a2};
                \State refs(lc + 1, a2) = {a1};
            \EndIf
\newline \Comment{Case 2: if one remaining path is empty split the shorter path}
            \If{(l1 = 0 $\And$ l2 > 0)}
                \State path(a1) = append(path(a1), $\neg$value(lc + 1, path(a2)));
                \State refs(lc + 1, a1) = {a2};
                \State refs(lc + 1, a2) = random\_select(refmax, union({a1}, refs(lc + 1, a2)));
            \EndIf
\algstore{ExchangeBreak}
\end{algorithmic}
\end{algorithm}

\begin{algorithm}[h]
\caption{Αλγόριθμος Exchange, μέρος 2ο}
\label{algo:ExchangePart2}
\begin{algorithmic}[1]
\algrestore{ExchangeBreak}
\item[] \Comment{Case 3: like case 2}
            \If{(l1 > 0 $\And$ l2 = 0)}
                \State path(a2) = append(path(a2), $\neg$value(lc + 1, path(a1)));
                \State refs(lc + 1, a2) = {a1};
                \State refs(lc + 1, a1) = random\_select(refmax, union({a2}, refs(lc + 1, a1)));
            \EndIf
\newline \Comment{Case 4: recursively perform exchange with referenced peers}
            \If{(l1 > 0 $\And$ l2 > 0 $\And$ r < recmax)}
                \State refs1 = refs(lc + 1, a1) $\setminus$ {a2};
                \State refs2 = refs(lc + 1, a2) $\setminus$ {a1};
                \For{r1 $\in$ refs1}
                    \If{online(peer(r1))}
                        \State exchange(a2, peer(r1), r + 1)
                    \EndIf
                \EndFor
                \For{r2 $\in$ refs2}
                    \If{online(peer(r2))}
                        \State exchange(a1, peer(r2), r + 1)
                    \EndIf
                \EndFor
            \EndIf
        \EndIf
  \EndProcedure
\end{algorithmic}
\end{algorithm}


\section{Πρωτόκολλο Ανοχής Λαθών (Fault-Tolerance)}
\label{sec:Fault}

\subsection{Γενικά}

Για να κατανοήσουμε τι είναι η ανοχή λαθών ας δούμε τα χαρακτηριστικά 
ενός αξιόπιστου συστήματος. 

\begin{description}
\item [Διαθεσιμότητα (Availability).] Αντιπροσωπεύει την ετοιμότητα του 
συστήματος. Συγκεκριμένα είναι η πιθανότητα το σύστημα να λειτουργεί 
σωστά σε κάποιες χρονικές στιγμές και να εκτελεί σωστά τη 
λειτουργικότητα που προσφέρει.
\item [Αξιοπιστία (Reliability).] Είναι η ικανότητα του συστήματος να 
λειτουργεί συνεχόμενα χωρίς αποτυχίες. Είναι η πιθανότητα να λειτουργεί 
σε ένα χρονικό διάστημα.
\item [Ασφάλεια (Safety).] Η κατάσταση όπου το σύστημα αποτυγχάνει 
προσωρινά χωρίς να συμβεί κάτι καταστροφικό.
\item [Δυνατότητα συντήρησης (Maintainability).] Η ευκολία με την οποία 
επιδιορθώνεται το σύστημα.
\end{description}

Η εκπλήρωση των παραπάνω χαρακτηριστικών επιτυγχάνεται με τη μείωση των 
αποτυχιών που συμβαίνουν στο σύστημα και την συνεχή παροχή των υπηρεσιών 
του για το οποίο έχει σχεδιαστεί. Αυτή είναι και η ουσία της έννοιας 
«ανοχή λαθών». Οι αποτυχίες χωρίζονται σε διάφορες κατηγορίες. Μπορεί να 
είναι παροδική, επαναλαμβανόμενη ή μόνιμη όσον αφορά τη συμπεριφορά της 
σε σχέση με τον χρόνο. Οι λόγοι που αναγνωρίζεται κάτι ως αποτυχία είναι 
η διακοπή λειτουργίας μέρους του δικτύου (crash). Μπορεί όμως διάφοροι 
peer να λειτουργούν κανονικά και σωστά αλλά να απαντούν σε μηνύματα μετά 
από κάποιο χρόνο timeout. Αντίστοιχο πρόβλημα είναι η παράληψη αποστολής 
ή παραλαβής μηνυμάτων το οποίο μπορεί να αντιμετωπιστεί ως αποτυχία. 
Επίσης, είναι πιθανό να στέλνονται λάθος απαντήσεις είτε κατά λάθος είτε 
κακόβουλα (Byzantine). Να σημειωθεί πως κάποια από τα προβλήματα 
αντιμετωπίζονται απλά. Παράδειγμα στην περίπτωση αργοπορίας απάντησης 
λόγω timeout μπορεί να δοθούν επιπλέον ευκαιρίες ώστε να εξακριβωθεί η 
κατάσταση του peer.

Τα παραπάνω είναι μια κατηγορία προβλημάτων που επηρεάζουν την κατάσταση 
του δικτύου. Επιπλέον, έχουμε και τη συνεχή σύνδεση και αποχώρηση των 
peer από το δίκτυο χωρίς να μπορούμε να προβλέψουμε τον χρόνο 
συμμετοχής. Αυτό το φαινόμενο ονομάζεται churn \citep{Buford2009}. 

Συνολικά, οι δομές που διατηρεί κάθε peer, όπως τον πίνακα δρομολόγησης, 
αν δεν ανανεωθούν τότε αυξάνεται η καθυστέρηση του συστήματος. Ο αριθμός 
των μηνυμάτων αυξάνεται αφού πολλά στέλνονται σε μη διαθέσιμους peer και 
αυτή η καθυστέρηση είναι συνέπεια των timeout των απαντήσεων. Επομένως, 
χρειαζόμαστε μια συνολική στρατηγική για τη συντήρηση του δικτύου. 
Επομένως, τα προβλήματα είναι πώς θα ανιχνευτεί μια αποτυχία, πώς θα την 
διορθώσει το σύστημα και γενικά πώς θα δράσει απέναντι στο φαινόμενο 
churn.

Κάθε peer είτε αποθηκεύει στον πίνακα δρομολόγησης τους γείτονες του 
είτε έχει επιπλέον δομές και κρατάει επιπλέον πληροφορίες. Έχουμε 
διάφορες προσεγγίσεις στο πότε θα εκκινηθεί η διαδικασία συντήρησης:

\begin{enumerate}
\item Ενεργή συντήρηση. Όταν ένας peer αποτυγχάνει ή αποχωρεί από το 
δίκτυο τότε κάποιος από τους γείτονες του ενημερώνει τους υπόλοιπους 
ανταλλάσοντας πληροφορίες για τους ενεργούς. Είτε μπορεί να στείλει τις 
λίστες με τους γείτονες που αποθηκεύει είτε τη διαφορά αυτών σε σύγκριση 
με προηγούμενη κατάσταση. Όπως θα δούμε παρακάτω αυτή την τακτική 
ακολουθούν τα συστήματα Pastry και Tapestry.
\item Ευκαιριακή συντήρηση. Περιοδικά ο peer ανταλλάσει τις δομές όπου 
αποθηκεύει τους γείτονες του επιλέγοντας έναν peer από αυτές. Αντίστοιχα 
ελέγχουν και ανανεώνουν την κατάσταση των γειτόνων τους. Το Chord 
ακολουθεί αυτό το παράδειγμα.
\end{enumerate}

Η ανίχνευση της αποτυχίας μπορεί να γίνει μέσω περιοδικών ping ή 
εφαρμογή πρωτοκόλλων gossiping. Μπορεί να ακολουθηθεί και πιο παθητική 
στάση αναμένοντας μηνύματα ενημέρωσης αποτυχίας.

Στο Pastry \citep{Pastry} χρησιμοποιείται ένας gossip αλγόριθμος μέσω 
του οποίου ανανεώνεται ο πίνακας δρομολόγησης. Όταν ανακαλυφθεί και 
διαπιστωθεί πως είναι αποτυχία καταγράφεται και εκκινείτε η διαδικασία 
επιδιόρθωσης. Στο Tapestry \citep{Tapestry} ακολουθείται η τακτική του 
πλεονασμού (redundancy) όσον αφορά τις αναφορές που αποθηκεύει στον 
πίνακα δρομολόγησης. Οπότε στην είσοδο/έξοδο ενός peer καθώς και σε 
αποτυχία ενημερώνει εκείνο το κομμάτι του δικτύου που αφορά τον peer και 
αντίστοιχα ανανεώνεται ο πίνακας. Στο Chord \citep{Chord} κάθε peer 
κρατά μια λίστα με peer διαδόχους (successor). Στην περίπτωση αποτυχίας 
επικοινωνεί με τον πιο κοντινό του τοπολογικά για να λύσει το πρόβλημα. 
Στην περίπτωση του P-Grid έχουμε την εφαρμογή της τεχνικής της 
αντιγραφής (replication). Υπάρχουν peer αντίγραφα άλλων που ο ρόλος τους 
είναι να πάρουν την θέση τους στην περίπτωση που αποτύχουν. 
Η τεχνική του replication όμως στερεί
%ΠΟΙΟ ΕΙΝΑΙ ΤΟ ΠΡΟΒΛΗΜΑ ΜΕ ΤΙΣ ΤΕΧΝΙΚΕΣ REDUNDANCY 
%ΚΑΙ REPLICATION;

\subsection{Αλγόριθμος Επιδιόρθωσης}

\begin{algorithm}
\caption{Αλγόριθμος FindContinuation}
\label{algo:continuation}
\begin{algorithmic}[1]
  \Procedure{p.FindContinuation}{pathTrace}
        \If{p.isPrefixOf(pathTrace)}
            \State \Return p.closestLevelTo(pathTrace)
        \EndIf
        \If{path(p) $\equiv$ pathTrace}
            \State \Return p
        \EndIf
        \If{path(p).length() $\leq$ pathTrace.length()}
            \State \Return p.closestLevelTo(pathTrace)
        \EndIf
        \State route1 $\gets$ pathTrace.revertAndAppend(pathTrace.lastBit())
        \State route2 $\gets$ pathTrace.Append(pathTrace.lastBit())
        \If{p.hasPrefix(route1)}
            \If{path(p).length() $<$ route1.length()}
                \If{path(p) $\equiv$ route1}
                    \State \Return p
                \Else
                    \State \Return p.FindContinuation(route1)
                \EndIf
            \Else
                \State \Return p.closestLevelTo(route2)
            \EndIf
        \Else
            \If{p.hasPrefix(route2)}
                \If{p has conjugate peer and not a subtree}
                    \State \Return p
                \Else
                    \State \Return p.closestLevelTo(route1)
                \EndIf
            \Else
                \State \Return p.FindContinuation(route2)
            \EndIf
        \EndIf

  \EndProcedure
\end{algorithmic}
\end{algorithm}

\begin{algorithm}
\caption{Αλγόριθμος Replace}
\label{algo:replace}
\begin{algorithmic}[1]
  \Procedure{p.Replace}{failed}
        \If{failed.isConjugateTo(p)}
            \State path(p).reduceBy(1)
        \Else
            \If{path(p).endsWith('1')}
	            \State path(p) $\gets$ path(failed)
            \Else
                \State path(p).reduceBy(1)
            \EndIf
        \EndIf
        \State p.refreshRoutingTable()
  \EndProcedure
\end{algorithmic}
\end{algorithm}
